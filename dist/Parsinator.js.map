{
  "version": 3,
  "sources": ["../src/Parsinator.ts", "../src/lib/ParserTypes.ts", "../src/lib/ParserHelpers.ts", "../src/lib/Parser.ts", "../src/lib/ParserCombinators.ts"],
  "sourcesContent": ["declare const BUILD_VERSION: string | undefined;\n\nexport const VERSION =\n  typeof BUILD_VERSION === \"undefined\" ? \"debug\" : BUILD_VERSION;\n\nexport {\n  str,\n  regex,\n  regexMatch,\n  end,\n  fail,\n  wrapFail,\n  debugTrace,\n  run,\n  runToEnd,\n  fromGenerator,\n} from \"./lib/Parser\";\n\nexport {\n  maybe,\n  many,\n  many1,\n  choice,\n  sequence,\n  count,\n  sepBy,\n  sepBy1,\n  peek,\n  until,\n  between,\n  map,\n  surround,\n  OperatorActionUnary,\n  OperatorActionBinary,\n  OperatorDeclBinary,\n  OperatorDeclUnary,\n  OperatorDecl,\n  OperatorDecls,\n  buildExpressionParser,\n} from \"./lib/ParserCombinators\";\n\nexport { Parser, ParseError, ParseState, ParseResult } from \"./lib/ParserTypes\";\n", "export interface ParseState {\n  input: string;\n  offset: number;\n}\nexport interface ParseResult<T> {\n  value: T;\n  state: ParseState;\n}\n\nexport interface Parser<T> {\n  (): Generator<number | ParseState, T, ParseState>;\n  [Symbol.iterator](): Generator<number | ParseState, T, ParseState>;\n  parserName: string;\n}\n\nexport class ParseError extends Error {\n  public line: number;\n  public col: number;\n  public offset: number;\n  public input: string;\n  public msg: string;\n  public state: ParseState;\n\n  constructor(msg: string, line: number, col: number, state: ParseState) {\n    super(`Parse failure at ${line}:${col}: ${msg}\\n${formatState(state)}`);\n    this.line = line;\n    this.col = col;\n    this.msg = msg;\n    this.state = state;\n    this.offset = state.offset;\n    this.input = state.input;\n  }\n}\n\nexport function formatState(state: ParseState): string {\n  var startOffset = Math.max(0, state.offset - 40);\n  var endOffset = Math.min(state.input.length, state.offset + 40);\n  var substr =\n    (startOffset === 0 ? \"\" : \"...\") +\n    state.input.replace(/[\\t\\r\\n\\v\\f]/g, \"\u00B7\").slice(startOffset, endOffset) +\n    (endOffset === state.input.length ? \"\" : \"...\");\n  var charsBefore =\n    (startOffset === 0 ? 0 : 3) +\n    state.input.slice(startOffset, state.offset).length;\n  var marker = \" \".repeat(charsBefore) + \"^\";\n  return `-> \u00AB${substr}\u00BB\\n    ${marker} `;\n}\n", "import { ParseError, ParseState, ParseResult } from \"./ParserTypes\";\n\nexport function resultSuccess<T>(\n  value: T,\n  input: string,\n  offset: number\n): ParseResult<T> {\n  return {\n    value: value,\n    state: {\n      input: input,\n      offset: offset,\n    },\n  };\n}\n\nexport function resultFailure<T>(msg: string, state: ParseState): ParseError {\n  var lines = 0;\n  var lastLineStart = 0;\n  for (var i = 0; i < state.offset; ++i) {\n    if (state.input[i] === \"\\n\") {\n      lines++;\n      lastLineStart = i + 1;\n    }\n  }\n  var line = 1 + lines;\n  var col = 1 + state.offset - lastLineStart;\n  return new ParseError(msg, line, col, state);\n}\n", "import {\n  Parser,\n  ParseState,\n  ParseResult,\n  ParseError,\n  formatState,\n} from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\n\nexport function makeParser<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName: string\n): Parser<V> {\n  return Object.assign(() => generator(), {\n    [Symbol.iterator]: generator,\n    parserName,\n  });\n}\n\n/**\n * Produce the full string match from a regular expression.\n *\n * @param regex The regular expression to match\n * @return A parser producing the string matched by the regular expression\n */\nexport function regex(regex: RegExp): Parser<string> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return result[0];\n  }, `regex:${regex.source}`);\n}\n\n/**\n * Produce the full match and all groups from a regular expression.\n *\n * Produces a string array; item 0 is the full match.\n *\n * @param regex The regular expression to match\n * @return A parser producing an array of matching groups; item 0 is the full matching string\n */\nexport function regexMatch(regex: RegExp): Parser<string[]> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return Array.from(result);\n  }, `regexMatch:${regex.source}`);\n}\n\n/**\n * Produce a string value.\n *\n * @param string the string value to parse\n * @return A parser producing the matched string\n */\nexport function str<T extends string>(string: T): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    if (state.input.substr(state.offset, string.length) === string) {\n      yield string.length;\n      return string;\n    } else {\n      throw resultFailure(`\"${string}\" not found`, state);\n    }\n  }, `str:${string}`);\n}\n\n/**\n * Produce the return value of the generator, which may yield to sub-parsers.\n *\n * Yielded parsers evaluate to their produced value.\n *\n * @param generator A generator function which yields Parsers and returns value\n * @return A parser producing the returned value\n */\nexport function fromGenerator<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName?: string\n): Parser<V> {\n  return makeParser(function* () {\n    let state: ParseState = yield 0;\n    var iterator: Iterator<number | ParseState, V, ParseState> = generator();\n    while (true) {\n      var result = iterator.next(state);\n      if (result.done) {\n        yield state;\n        return result.value;\n      } else {\n        if (typeof result.value === \"number\") {\n          state = { ...state, offset: state.offset + result.value };\n        } else {\n          state = result.value;\n        }\n        yield state;\n      }\n    }\n  }, parserName || generator.name);\n}\n\n/**\n * Return a parser which always fails with a specific error message.\n *\n * @param message the message to fail with\n */\nexport function fail<T>(message: string): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    throw resultFailure(message, state);\n  }, `fail:${message}`);\n}\n\n/**\n * Return a parser which when the wrapped parser fails, provides an alternate error message.\n *\n * @param parser a parser whose error message is inadequate\n * @param wrapper a function to add more information to an error message\n */\nexport function wrapFail<T>(\n  parser: Parser<T>,\n  wrapper: (message: string) => string\n) {\n  return makeParser(function* () {\n    try {\n      return yield* parser;\n    } catch (e) {\n      if (e instanceof ParseError) {\n        const message = wrapper(e.msg);\n        throw resultFailure(message, { input: e.input, offset: e.offset });\n      }\n      throw e;\n    }\n  }, \"wrapFail\");\n}\n\n/**\n * Produce nothing and consume nothing, just log the parser state to a log\n *\n * @param log A logging function\n */\nexport function debugTrace(log: (str: string) => void): Parser<undefined> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    log(formatState(state));\n    return undefined;\n  }, \"debugTrace\");\n}\n\n/**\n * @var end A parser which produces null at the end of input and fails if there is more input.\n */\nexport const end: Parser<null> = makeParser(function* () {\n  const state: ParseState = yield 0;\n  if (state.offset >= state.input.length) {\n    return null;\n  } else {\n    throw resultFailure(\"Not at end of string\", state);\n  }\n}, \"end\");\n\nfunction runInner<T>(parser: Parser<T>, state: ParseState): ParseResult<T> {\n  const iter = parser();\n  let step = iter.next(state);\n  while (!step.done) {\n    if (typeof step.value === \"number\") {\n      state = { ...state, offset: state.offset + step.value };\n    } else {\n      state = step.value;\n    }\n    step = iter.next(state);\n  }\n  return {\n    value: step.value,\n    state: state,\n  };\n}\n\n/**\n * Run a parser on an input, returning the parser's produced value.\n *\n * The parser does not need to consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function run<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  return runInner(parser, state).value;\n}\n\n/**\n * Run a parser on the full input, returning the parser's produced value.\n *\n * Fails if the parser does not consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function runToEnd<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  const result = runInner(parser, state);\n  const next = runInner(end, result.state); // throws on error\n  return result.value;\n}\n", "import { Parser, ParseState, ParseResult, ParseError } from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\nimport { fromGenerator } from \"./Parser\";\n\n/**\n * Produce the parser's produced value or null on failure.\n *\n * @param parser the parser to attempt\n * @return a parser producing the wrapped parser's result or null on failure\n */\nexport function maybe<P>(parser: Parser<P>): Parser<P | null> {\n  return fromGenerator(function* maybe() {\n    const startState = yield 0;\n    try {\n      return yield* parser;\n    } catch (e) {\n      yield startState;\n      return null;\n    }\n  }, `maybe(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser any number of times (including zero).\n *\n * @param parser a parser to match multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many() {\n    var results: P[] = [];\n    while (true) {\n      const state = yield 0;\n      try {\n        var result = yield* parser;\n      } catch (e) {\n        yield state;\n        return results;\n      }\n      results.push(result);\n    }\n  }, `many(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser at least once.\n *\n * @param parser the parser to execute multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many1<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many1() {\n    var one = yield* parser;\n    var multiple = yield* many(parser);\n    return [one].concat(multiple);\n  }, `many1(${parser.parserName})`);\n}\n\n/**\n * Produce the first successful result of matching the provided parsers.\n *\n * @param parsers an array of parsers to try\n * @return a parser producing the first succeeding parser's value\n */\nexport function choice<V>(parsers: Parser<V>[]): Parser<V> {\n  return fromGenerator(function* choice() {\n    var errors: ParseError[] = [];\n    const startState = yield 0;\n    for (var i = 0; i < parsers.length; ++i) {\n      try {\n        return yield* parsers[i];\n      } catch (e) {\n        if (e instanceof ParseError) {\n          errors.push(e);\n        } else {\n          throw e;\n        }\n        yield startState;\n      }\n    }\n    const state = yield 0;\n    yield startState;\n    errors.sort((a, b) => b.offset - a.offset);\n    throw resultFailure(\n      \"Multiple choices; potential matches:\\n- \" +\n        errors\n          .map((error) => error.message.split(\"\\n\").join(\"\\n  \"))\n          .join(\"\\n- \"),\n      state\n    );\n  }, `choice(${parsers.map((parser) => parser.parserName).join(\",\")})`);\n}\n\n/**\n * Produce a parser which runs the parsers in sequence, returning an array of results.\n *\n * @param parsers the parsers to execute in sequence\n * @return a parser producing an array of parsed values\n */\nexport function sequence<V>(parsers: Parser<V>[]): Parser<V[]> {\n  return fromGenerator(function* sequence() {\n    var results: V[] = [];\n    for (var i = 0; i < parsers.length; ++i) {\n      const state = yield 0;\n      results.push(yield* parsers[i]);\n    }\n    return results;\n  }, `sequence(${parsers.map((parser) => parser.name).join(\",\")})`);\n}\n\n/**\n * Produce an array of values from a parser run a specific number of times.\n *\n * @param num the number of times to run the parser\n * @param parser the parser to repeat\n * @return a parser producing an array of parsed values\n */\nexport function count<V>(num: number, parser: Parser<V>): Parser<V[]> {\n  return fromGenerator(function* count() {\n    var results: V[] = [];\n    for (var i = 0; i < num; ++i) {\n      results.push(yield* parser);\n    }\n    return results;\n  }, `count(${num},${parser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser must match at least once.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy1<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  return fromGenerator(function* sepBy1() {\n    var results: V[] = [];\n    while (true) {\n      results.push(yield* valParser);\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n    }\n  }, `sepBy1(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser may not match at all.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  var maybeParser = maybe(valParser);\n  return fromGenerator(function* sepBy() {\n    var results: V[] = [];\n    var first = yield* maybeParser;\n    if (first === null) {\n      return results;\n    } else {\n      results.push(first);\n    }\n    while (true) {\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n      results.push(yield* valParser);\n    }\n  }, `sepBy(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce a value by running the parser, but not advancing the parsed state.\n *\n * @param parser a parser producing any value\n * @return a parser producing the wrapped parser's value\n */\nexport function peek<P>(parser: Parser<P>): Parser<P> {\n  return fromGenerator(function* peek() {\n    const startState = yield 0;\n    let result: P;\n    try {\n      result = yield* parser;\n    } catch (e) {\n      yield startState;\n      throw e;\n    }\n    yield startState;\n    return result;\n  }, `peek(${parser.parserName})`);\n}\n\n/**\n * Produce the string input consumed until the terminator parser matches.\n *\n * The terminator parser is not consumed.\n *\n * @param terminator A parser that consumes an end token\n * @return A parser producing the string input consumed until the terminator parser.\n */\nexport function until<T>(terminator: Parser<T>): Parser<string> {\n  return fromGenerator(function* until() {\n    let state = yield 0;\n    for (var i = state.offset; i <= state.input.length; ++i) {\n      // why i <= len? end terminators only match if offset = len.\n      // Try setting state\n      const maybeEndState = yield { ...state, offset: i };\n      try {\n        yield* terminator;\n        yield maybeEndState;\n        return state.input.slice(state.offset, i);\n      } catch (e) {\n        // ignore and proceed\n      }\n    }\n    throw resultFailure(\"Didn't find terminator\", state);\n  }, `until(${terminator.parserName})`);\n}\n\n/**\n * Produce the string input between the start and end parsers.\n *\n * @param start A parser consuming a start token\n * @param end A parser consuming an end token\n */\nexport function between<T>(start: Parser<T>, end: Parser<T>): Parser<string> {\n  return fromGenerator(function* between() {\n    yield* start;\n    var data = yield* until(end);\n    yield* end;\n    return data;\n  }, `between(${start.parserName},${end.parserName})`);\n}\n\n/**\n * Produce a value transformed by a provided function.\n *\n * @param parser the parser to wrap\n * @param fn function to transform the value produced by the parsed\n */\nexport function map<V, W>(parser: Parser<V>, fn: (val: V) => W): Parser<W> {\n  return fromGenerator(function* map() {\n    var result = yield* parser;\n    return fn(result);\n  }, `map(${parser.parserName})`);\n}\n\n/**\n * Produce a value obtained after a prefix parser and before a suffix parser\n *\n * @param left a prefix parser that the produced value is ignored\n * @param val the parser whose produced value is desired\n * @param right a suffix parser that the produced value is ignored\n */\nexport function surround<L, T, R>(\n  left: Parser<L>,\n  val: Parser<T>,\n  right: Parser<R>\n): Parser<T> {\n  return fromGenerator(function* surround() {\n    yield* left;\n    var v: T = yield* val;\n    yield* right;\n    return v;\n  }, `surround(${left.parserName},${val.parserName},${right.parserName})`);\n}\n\nexport type OperatorActionUnary<T> = (val: T) => T;\nexport interface OperatorDeclUnary<T> {\n  parser: Parser<OperatorActionUnary<T>>;\n  fixity: \"prefix\" | \"postfix\";\n}\n\nexport type OperatorActionBinary<T> = (left: T, right: T) => T;\nexport interface OperatorDeclBinary<T> {\n  parser: Parser<OperatorActionBinary<T>>;\n  fixity: \"infix\";\n  associativity: \"left\" | \"right\";\n}\n\nexport type OperatorDecl<T> = OperatorDeclUnary<T> | OperatorDeclBinary<T>;\nexport type OperatorDecls<T> = OperatorDecl<T>[];\n\n/**\n * Build a parser which parses and produces arbitrary binary and unary expressions.\n *\n * buildExpressionParser deals with the heavy lifting of dealing with operator fixity, precedence, and associativity.\n *\n * As an example, here's a very simple arithmetic parser:\n *\n *     var number = Parser.map(Parser.regex(/[0-9]+/), (str) => parseInt(str, 10));\n *\n *     var operator = (opstr, action) => Parser.map(Parser.str(opstr), () => action);\n *\n *     var negate = operator('-', (val) => -val);\n *     var sum = operator('+', (x, y) => x + y);\n *     var multiply = operator('*', (x, y) => x * y);\n *     var exponent = operator('^', (x, y) => Math.pow(x, y));\n *\n *     var evaluate = Parser.buildExpressionParser([\n *         { fixity: \"prefix\", parser: negate },\n *         { fixity: \"infix\", associativity: \"right\", parser: exponent },\n *         { fixity: \"infix\", associativity: \"left\", parser: multiply },\n *         { fixity: \"infix\", associativity: \"left\", parser: sum }\n *     ], () => Parser.choice([\n *         Parser.surround(Parser.str(\"(\"), evaluate, Parser.str(\")\")),\n *         number\n *     ]));\n *\n *     Parser.runToEnd(evaluate, \"1+2*3+1\"); // evaluates to 8\n *     Parser.runToEnd(evaluate, \"(1+2)*-(3+1)\"); // evaluates to -12\n *     Parser.runToEnd(evaluate, \"3^3^3\"); // evaluates to 7625597484987\n *\n * @param operators A an array of `OperatorDecl` objects, in precedence order from highest precedence to lowest precedence\n * @param parseTermFactory A factory method that returns a parser which produces the individual terms of an expression; this itself may reference the returned parser, so it can be used to implement parenthetical sub-expressions\n */\nexport function buildExpressionParser<T>(\n  operators: OperatorDecls<T>,\n  parseTermFactory: () => Parser<T>\n): Parser<T> {\n  var parseTerm: Parser<T> | null = null;\n  var preOps: Parser<OperatorActionUnary<T>>[] = [];\n  var postOps: Parser<OperatorActionUnary<T>>[] = [];\n  var binOps: {\n    precedence: number;\n    associativity: \"left\" | \"right\";\n    parser: Parser<OperatorActionBinary<T>>;\n  }[] = [];\n  for (let i = 0; i < operators.length; ++i) {\n    let precedence: number = operators.length - i;\n    let operator = operators[i];\n    switch (operator.fixity) {\n      case \"infix\":\n        binOps.push({\n          precedence,\n          associativity: operator.associativity,\n          parser: operator.parser,\n        });\n        break;\n      case \"postfix\":\n        postOps.push(operator.parser);\n        break;\n      case \"prefix\":\n        preOps.push(operator.parser);\n        break;\n    }\n  }\n\n  var parseExprTerm = fromGenerator(function* exprParserTerm() {\n    var preFuncs: OperatorActionUnary<T>[] = [];\n    var postFuncs: OperatorActionUnary<T>[] = [];\n    var f: OperatorActionUnary<T> | null = null;\n    do {\n      f = yield* maybe(choice(preOps));\n      if (f !== null) {\n        preFuncs.push(f);\n      }\n    } while (f !== null);\n    if (parseTerm === null) {\n      parseTerm = parseTermFactory();\n    }\n    var result: T = yield* parseTerm;\n    do {\n      f = yield* maybe(choice(postOps));\n      if (f !== null) {\n        postFuncs.push(f);\n      }\n    } while (f !== null);\n    for (let f of preFuncs) {\n      result = f(result);\n    }\n    for (let f of postFuncs) {\n      result = f(result);\n    }\n    return result;\n  }, `expressionParser:term`);\n\n  // This uses the precedence climbing/TDOP algorithm\n  // See http://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing\n  function parseExpressionPrecedence(minPrec: number): Parser<T> {\n    return fromGenerator(function* exprParserPrecedence() {\n      var left: T = yield* parseExprTerm;\n      while (true) {\n        var action: OperatorActionBinary<T> | null = null;\n        var associativity: \"left\" | \"right\" | undefined;\n        var precedence: number | undefined;\n        for (var i = 0; i < binOps.length && action === null; ++i) {\n          var op = binOps[i];\n          if (op.precedence >= minPrec) {\n            action = yield* maybe(op.parser);\n            associativity = op.associativity;\n            precedence = op.precedence;\n          }\n        }\n        if (action === null) {\n          // if action is not null, associativity and precedence are both not undefined\n          return left;\n        }\n        var nextMinPrec: number;\n        if (associativity === \"left\") {\n          nextMinPrec = <number>precedence + 1;\n        } else {\n          nextMinPrec = <number>precedence;\n        }\n        var right = yield* parseExpressionPrecedence(nextMinPrec);\n        left = action(left, right);\n      }\n    }, `expressionParser:precedence`);\n  }\n  return parseExpressionPrecedence(0);\n}\n"],
  "mappings": "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",
  "names": ["regex", "maybe", "many", "many1", "choice", "sequence", "count", "sepBy1", "sepBy", "peek", "until", "end", "between", "map", "surround", "f"]
}
