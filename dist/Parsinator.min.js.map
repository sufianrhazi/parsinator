{
  "version": 3,
  "sources": ["../src/Parsinator.ts", "../src/lib/ParserTypes.ts", "../src/lib/ParserHelpers.ts", "../src/lib/Parser.ts", "../src/lib/ParserCombinators.ts"],
  "sourcesContent": ["declare const BUILD_VERSION: string | undefined;\n\nexport const VERSION =\n  typeof BUILD_VERSION === undefined ? \"debug\" : BUILD_VERSION;\n\nexport {\n  str,\n  regex,\n  regexMatch,\n  end,\n  fail,\n  wrapFail,\n  debugTrace,\n  run,\n  runToEnd,\n  fromGenerator,\n} from \"./lib/Parser\";\n\nexport {\n  maybe,\n  many,\n  many1,\n  choice,\n  sequence,\n  count,\n  sepBy,\n  sepBy1,\n  peek,\n  until,\n  between,\n  map,\n  surround,\n  OperatorActionUnary,\n  OperatorActionBinary,\n  OperatorDeclBinary,\n  OperatorDeclUnary,\n  OperatorDecl,\n  OperatorDecls,\n  buildExpressionParser,\n} from \"./lib/ParserCombinators\";\n\nexport { Parser, ParseError, ParseState, ParseResult } from \"./lib/ParserTypes\";\n", "export interface ParseState {\n  input: string;\n  offset: number;\n}\nexport interface ParseResult<T> {\n  value: T;\n  state: ParseState;\n}\n\nexport interface Parser<T> {\n  (): Generator<number | ParseState, T, ParseState>;\n  [Symbol.iterator](): Generator<number | ParseState, T, ParseState>;\n  parserName: string;\n}\n\nexport class ParseError extends Error {\n  public line: number;\n  public col: number;\n  public offset: number;\n  public input: string;\n  public msg: string;\n  public state: ParseState;\n\n  constructor(msg: string, line: number, col: number, state: ParseState) {\n    super(`Parse failure at ${line}:${col}: ${msg}\\n${formatState(state)}`);\n    this.line = line;\n    this.col = col;\n    this.msg = msg;\n    this.state = state;\n    this.offset = state.offset;\n    this.input = state.input;\n  }\n}\n\nexport function formatState(state: ParseState): string {\n  var startOffset = Math.max(0, state.offset - 40);\n  var endOffset = Math.min(state.input.length, state.offset + 40);\n  var substr =\n    (startOffset === 0 ? \"\" : \"...\") +\n    state.input.replace(/[\\t\\r\\n\\v\\f]/g, \"\u00B7\").slice(startOffset, endOffset) +\n    (endOffset === state.input.length ? \"\" : \"...\");\n  var charsBefore =\n    (startOffset === 0 ? 0 : 3) +\n    state.input.slice(startOffset, state.offset).length;\n  var marker = \" \".repeat(charsBefore) + \"^\";\n  return `-> \u00AB${substr}\u00BB\\n    ${marker} `;\n}\n", "import { ParseError, ParseState, ParseResult } from \"./ParserTypes\";\n\nexport function resultSuccess<T>(\n  value: T,\n  input: string,\n  offset: number\n): ParseResult<T> {\n  return {\n    value: value,\n    state: {\n      input: input,\n      offset: offset,\n    },\n  };\n}\n\nexport function resultFailure<T>(msg: string, state: ParseState): ParseError {\n  var lines = 0;\n  var lastLineStart = 0;\n  for (var i = 0; i < state.offset; ++i) {\n    if (state.input[i] === \"\\n\") {\n      lines++;\n      lastLineStart = i + 1;\n    }\n  }\n  var line = 1 + lines;\n  var col = 1 + state.offset - lastLineStart;\n  return new ParseError(msg, line, col, state);\n}\n", "import {\n  Parser,\n  ParseState,\n  ParseResult,\n  ParseError,\n  formatState,\n} from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\n\nexport function makeParser<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName: string\n): Parser<V> {\n  return Object.assign(() => generator(), {\n    [Symbol.iterator]: generator,\n    parserName,\n  });\n}\n\n/**\n * Produce the full string match from a regular expression.\n *\n * @param regex The regular expression to match\n * @return A parser producing the string matched by the regular expression\n */\nexport function regex(regex: RegExp): Parser<string> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return result[0];\n  }, `regex:${regex.source}`);\n}\n\n/**\n * Produce the full match and all groups from a regular expression.\n *\n * Produces a string array; item 0 is the full match.\n *\n * @param regex The regular expression to match\n * @return A parser producing an array of matching groups; item 0 is the full matching string\n */\nexport function regexMatch(regex: RegExp): Parser<string[]> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return Array.from(result);\n  }, `regexMatch:${regex.source}`);\n}\n\n/**\n * Produce a string value.\n *\n * @param string the string value to parse\n * @return A parser producing the matched string\n */\nexport function str<T extends string>(string: T): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    if (state.input.substr(state.offset, string.length) === string) {\n      yield string.length;\n      return string;\n    } else {\n      throw resultFailure(`\"${string}\" not found`, state);\n    }\n  }, `str:${string}`);\n}\n\n/**\n * Produce the return value of the generator, which may yield to sub-parsers.\n *\n * Yielded parsers evaluate to their produced value.\n *\n * @param generator A generator function which yields Parsers and returns value\n * @return A parser producing the returned value\n */\nexport function fromGenerator<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName?: string\n): Parser<V> {\n  return makeParser(function* () {\n    let state: ParseState = yield 0;\n    var iterator: Iterator<number | ParseState, V, ParseState> = generator();\n    while (true) {\n      var result = iterator.next(state);\n      if (result.done) {\n        yield state;\n        return result.value;\n      } else {\n        if (typeof result.value === \"number\") {\n          state = { ...state, offset: state.offset + result.value };\n        } else {\n          state = result.value;\n        }\n        yield state;\n      }\n    }\n  }, parserName || generator.name);\n}\n\n/**\n * Return a parser which always fails with a specific error message.\n *\n * @param message the message to fail with\n */\nexport function fail<T>(message: string): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    throw resultFailure(message, state);\n  }, `fail:${message}`);\n}\n\n/**\n * Return a parser which when the wrapped parser fails, provides an alternate error message.\n *\n * @param parser a parser whose error message is inadequate\n * @param wrapper a function to add more information to an error message\n */\nexport function wrapFail<T>(\n  parser: Parser<T>,\n  wrapper: (message: string) => string\n) {\n  return makeParser(function* () {\n    try {\n      return yield* parser;\n    } catch (e) {\n      if (e instanceof ParseError) {\n        const message = wrapper(e.msg);\n        throw resultFailure(message, { input: e.input, offset: e.offset });\n      }\n      throw e;\n    }\n  }, \"wrapFail\");\n}\n\n/**\n * Produce nothing and consume nothing, just log the parser state to a log\n *\n * @param log A logging function\n */\nexport function debugTrace(log: (str: string) => void): Parser<undefined> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    log(formatState(state));\n    return undefined;\n  }, \"debugTrace\");\n}\n\n/**\n * @var end A parser which produces null at the end of input and fails if there is more input.\n */\nexport const end: Parser<null> = makeParser(function* () {\n  const state: ParseState = yield 0;\n  if (state.offset >= state.input.length) {\n    return null;\n  } else {\n    throw resultFailure(\"Not at end of string\", state);\n  }\n}, \"end\");\n\nfunction runInner<T>(parser: Parser<T>, state: ParseState): ParseResult<T> {\n  const iter = parser();\n  let step = iter.next(state);\n  while (!step.done) {\n    if (typeof step.value === \"number\") {\n      state = { ...state, offset: state.offset + step.value };\n    } else {\n      state = step.value;\n    }\n    step = iter.next(state);\n  }\n  return {\n    value: step.value,\n    state: state,\n  };\n}\n\n/**\n * Run a parser on an input, returning the parser's produced value.\n *\n * The parser does not need to consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function run<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  return runInner(parser, state).value;\n}\n\n/**\n * Run a parser on the full input, returning the parser's produced value.\n *\n * Fails if the parser does not consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function runToEnd<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  const result = runInner(parser, state);\n  const next = runInner(end, result.state); // throws on error\n  return result.value;\n}\n", "import { Parser, ParseState, ParseResult, ParseError } from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\nimport { fromGenerator } from \"./Parser\";\n\n/**\n * Produce the parser's produced value or null on failure.\n *\n * @param parser the parser to attempt\n * @return a parser producing the wrapped parser's result or null on failure\n */\nexport function maybe<P>(parser: Parser<P>): Parser<P | null> {\n  return fromGenerator(function* maybe() {\n    const startState = yield 0;\n    try {\n      return yield* parser;\n    } catch (e) {\n      yield startState;\n      return null;\n    }\n  }, `maybe(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser any number of times (including zero).\n *\n * @param parser a parser to match multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many() {\n    var results: P[] = [];\n    while (true) {\n      const state = yield 0;\n      try {\n        var result = yield* parser;\n      } catch (e) {\n        yield state;\n        return results;\n      }\n      results.push(result);\n    }\n  }, `many(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser at least once.\n *\n * @param parser the parser to execute multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many1<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many1() {\n    var one = yield* parser;\n    var multiple = yield* many(parser);\n    return [one].concat(multiple);\n  }, `many1(${parser.parserName})`);\n}\n\n/**\n * Produce the first successful result of matching the provided parsers.\n *\n * @param parsers an array of parsers to try\n * @return a parser producing the first succeeding parser's value\n */\nexport function choice<V>(parsers: Parser<V>[]): Parser<V> {\n  return fromGenerator(function* choice() {\n    var errors: ParseError[] = [];\n    const startState = yield 0;\n    for (var i = 0; i < parsers.length; ++i) {\n      try {\n        return yield* parsers[i];\n      } catch (e) {\n        if (e instanceof ParseError) {\n          errors.push(e);\n        } else {\n          throw e;\n        }\n        yield startState;\n      }\n    }\n    const state = yield 0;\n    yield startState;\n    errors.sort((a, b) => b.offset - a.offset);\n    throw resultFailure(\n      \"Multiple choices; potential matches:\\n- \" +\n        errors\n          .map((error) => error.message.split(\"\\n\").join(\"\\n  \"))\n          .join(\"\\n- \"),\n      state\n    );\n  }, `choice(${parsers.map((parser) => parser.parserName).join(\",\")})`);\n}\n\n/**\n * Produce a parser which runs the parsers in sequence, returning an array of results.\n *\n * @param parsers the parsers to execute in sequence\n * @return a parser producing an array of parsed values\n */\nexport function sequence<V>(parsers: Parser<V>[]): Parser<V[]> {\n  return fromGenerator(function* sequence() {\n    var results: V[] = [];\n    for (var i = 0; i < parsers.length; ++i) {\n      const state = yield 0;\n      results.push(yield* parsers[i]);\n    }\n    return results;\n  }, `sequence(${parsers.map((parser) => parser.name).join(\",\")})`);\n}\n\n/**\n * Produce an array of values from a parser run a specific number of times.\n *\n * @param num the number of times to run the parser\n * @param parser the parser to repeat\n * @return a parser producing an array of parsed values\n */\nexport function count<V>(num: number, parser: Parser<V>): Parser<V[]> {\n  return fromGenerator(function* count() {\n    var results: V[] = [];\n    for (var i = 0; i < num; ++i) {\n      results.push(yield* parser);\n    }\n    return results;\n  }, `count(${num},${parser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser must match at least once.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy1<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  return fromGenerator(function* sepBy1() {\n    var results: V[] = [];\n    while (true) {\n      results.push(yield* valParser);\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n    }\n  }, `sepBy1(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser may not match at all.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  var maybeParser = maybe(valParser);\n  return fromGenerator(function* sepBy() {\n    var results: V[] = [];\n    var first = yield* maybeParser;\n    if (first === null) {\n      return results;\n    } else {\n      results.push(first);\n    }\n    while (true) {\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n      results.push(yield* valParser);\n    }\n  }, `sepBy(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce a value by running the parser, but not advancing the parsed state.\n *\n * @param parser a parser producing any value\n * @return a parser producing the wrapped parser's value\n */\nexport function peek<P>(parser: Parser<P>): Parser<P> {\n  return fromGenerator(function* peek() {\n    const startState = yield 0;\n    let result: P;\n    try {\n      result = yield* parser;\n    } catch (e) {\n      yield startState;\n      throw e;\n    }\n    yield startState;\n    return result;\n  }, `peek(${parser.parserName})`);\n}\n\n/**\n * Produce the string input consumed until the terminator parser matches.\n *\n * The terminator parser is not consumed.\n *\n * @param terminator A parser that consumes an end token\n * @return A parser producing the string input consumed until the terminator parser.\n */\nexport function until<T>(terminator: Parser<T>): Parser<string> {\n  return fromGenerator(function* until() {\n    let state = yield 0;\n    for (var i = state.offset; i <= state.input.length; ++i) {\n      // why i <= len? end terminators only match if offset = len.\n      // Try setting state\n      const maybeEndState = yield { ...state, offset: i };\n      try {\n        yield* terminator;\n        yield maybeEndState;\n        return state.input.slice(state.offset, i);\n      } catch (e) {\n        // ignore and proceed\n      }\n    }\n    throw resultFailure(\"Didn't find terminator\", state);\n  }, `until(${terminator.parserName})`);\n}\n\n/**\n * Produce the string input between the start and end parsers.\n *\n * @param start A parser consuming a start token\n * @param end A parser consuming an end token\n */\nexport function between<T>(start: Parser<T>, end: Parser<T>): Parser<string> {\n  return fromGenerator(function* between() {\n    yield* start;\n    var data = yield* until(end);\n    yield* end;\n    return data;\n  }, `between(${start.parserName},${end.parserName})`);\n}\n\n/**\n * Produce a value transformed by a provided function.\n *\n * @param parser the parser to wrap\n * @param fn function to transform the value produced by the parsed\n */\nexport function map<V, W>(parser: Parser<V>, fn: (val: V) => W): Parser<W> {\n  return fromGenerator(function* map() {\n    var result = yield* parser;\n    return fn(result);\n  }, `map(${parser.parserName})`);\n}\n\n/**\n * Produce a value obtained after a prefix parser and before a suffix parser\n *\n * @param left a prefix parser that the produced value is ignored\n * @param val the parser whose produced value is desired\n * @param right a suffix parser that the produced value is ignored\n */\nexport function surround<L, T, R>(\n  left: Parser<L>,\n  val: Parser<T>,\n  right: Parser<R>\n): Parser<T> {\n  return fromGenerator(function* surround() {\n    yield* left;\n    var v: T = yield* val;\n    yield* right;\n    return v;\n  }, `surround(${left.parserName},${val.parserName},${right.parserName})`);\n}\n\nexport type OperatorActionUnary<T> = (val: T) => T;\nexport interface OperatorDeclUnary<T> {\n  parser: Parser<OperatorActionUnary<T>>;\n  fixity: \"prefix\" | \"postfix\";\n}\n\nexport type OperatorActionBinary<T> = (left: T, right: T) => T;\nexport interface OperatorDeclBinary<T> {\n  parser: Parser<OperatorActionBinary<T>>;\n  fixity: \"infix\";\n  associativity: \"left\" | \"right\";\n}\n\nexport type OperatorDecl<T> = OperatorDeclUnary<T> | OperatorDeclBinary<T>;\nexport type OperatorDecls<T> = OperatorDecl<T>[];\n\n/**\n * Build a parser which parses and produces arbitrary binary and unary expressions.\n *\n * buildExpressionParser deals with the heavy lifting of dealing with operator fixity, precedence, and associativity.\n *\n * As an example, here's a very simple arithmetic parser:\n *\n *     var number = Parser.map(Parser.regex(/[0-9]+/), (str) => parseInt(str, 10));\n *\n *     var operator = (opstr, action) => Parser.map(Parser.str(opstr), () => action);\n *\n *     var negate = operator('-', (val) => -val);\n *     var sum = operator('+', (x, y) => x + y);\n *     var multiply = operator('*', (x, y) => x * y);\n *     var exponent = operator('^', (x, y) => Math.pow(x, y));\n *\n *     var evaluate = Parser.buildExpressionParser([\n *         { fixity: \"prefix\", parser: negate },\n *         { fixity: \"infix\", associativity: \"right\", parser: exponent },\n *         { fixity: \"infix\", associativity: \"left\", parser: multiply },\n *         { fixity: \"infix\", associativity: \"left\", parser: sum }\n *     ], () => Parser.choice([\n *         Parser.surround(Parser.str(\"(\"), evaluate, Parser.str(\")\")),\n *         number\n *     ]));\n *\n *     Parser.runToEnd(evaluate, \"1+2*3+1\"); // evaluates to 8\n *     Parser.runToEnd(evaluate, \"(1+2)*-(3+1)\"); // evaluates to -12\n *     Parser.runToEnd(evaluate, \"3^3^3\"); // evaluates to 7625597484987\n *\n * @param operators A an array of `OperatorDecl` objects, in precedence order from highest precedence to lowest precedence\n * @param parseTermFactory A factory method that returns a parser which produces the individual terms of an expression; this itself may reference the returned parser, so it can be used to implement parenthetical sub-expressions\n */\nexport function buildExpressionParser<T>(\n  operators: OperatorDecls<T>,\n  parseTermFactory: () => Parser<T>\n): Parser<T> {\n  var parseTerm: Parser<T> | null = null;\n  var preOps: Parser<OperatorActionUnary<T>>[] = [];\n  var postOps: Parser<OperatorActionUnary<T>>[] = [];\n  var binOps: {\n    precedence: number;\n    associativity: \"left\" | \"right\";\n    parser: Parser<OperatorActionBinary<T>>;\n  }[] = [];\n  for (let i = 0; i < operators.length; ++i) {\n    let precedence: number = operators.length - i;\n    let operator = operators[i];\n    switch (operator.fixity) {\n      case \"infix\":\n        binOps.push({\n          precedence,\n          associativity: operator.associativity,\n          parser: operator.parser,\n        });\n        break;\n      case \"postfix\":\n        postOps.push(operator.parser);\n        break;\n      case \"prefix\":\n        preOps.push(operator.parser);\n        break;\n    }\n  }\n\n  var parseExprTerm = fromGenerator(function* exprParserTerm() {\n    var preFuncs: OperatorActionUnary<T>[] = [];\n    var postFuncs: OperatorActionUnary<T>[] = [];\n    var f: OperatorActionUnary<T> | null = null;\n    do {\n      f = yield* maybe(choice(preOps));\n      if (f !== null) {\n        preFuncs.push(f);\n      }\n    } while (f !== null);\n    if (parseTerm === null) {\n      parseTerm = parseTermFactory();\n    }\n    var result: T = yield* parseTerm;\n    do {\n      f = yield* maybe(choice(postOps));\n      if (f !== null) {\n        postFuncs.push(f);\n      }\n    } while (f !== null);\n    for (let f of preFuncs) {\n      result = f(result);\n    }\n    for (let f of postFuncs) {\n      result = f(result);\n    }\n    return result;\n  }, `expressionParser:term`);\n\n  // This uses the precedence climbing/TDOP algorithm\n  // See http://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing\n  function parseExpressionPrecedence(minPrec: number): Parser<T> {\n    return fromGenerator(function* exprParserPrecedence() {\n      var left: T = yield* parseExprTerm;\n      while (true) {\n        var action: OperatorActionBinary<T> | null = null;\n        var associativity: \"left\" | \"right\" | undefined;\n        var precedence: number | undefined;\n        for (var i = 0; i < binOps.length && action === null; ++i) {\n          var op = binOps[i];\n          if (op.precedence >= minPrec) {\n            action = yield* maybe(op.parser);\n            associativity = op.associativity;\n            precedence = op.precedence;\n          }\n        }\n        if (action === null) {\n          // if action is not null, associativity and precedence are both not undefined\n          return left;\n        }\n        var nextMinPrec: number;\n        if (associativity === \"left\") {\n          nextMinPrec = <number>precedence + 1;\n        } else {\n          nextMinPrec = <number>precedence;\n        }\n        var right = yield* parseExpressionPrecedence(nextMinPrec);\n        left = action(left, right);\n      }\n    }, `expressionParser:precedence`);\n  }\n  return parseExpressionPrecedence(0);\n}\n"],
  "mappings": "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",
  "names": ["Parsinator_exports", "__export", "ParseError", "VERSION", "between", "buildExpressionParser", "choice", "count", "debugTrace", "end", "fail", "fromGenerator", "many", "many1", "map", "maybe", "peek", "regex", "regexMatch", "run", "runToEnd", "sepBy", "sepBy1", "sequence", "str", "surround", "until", "wrapFail", "ParseError", "msg", "line", "col", "state", "formatState", "startOffset", "endOffset", "substr", "charsBefore", "marker", "resultFailure", "msg", "state", "lines", "lastLineStart", "i", "line", "col", "ParseError", "makeParser", "generator", "parserName", "regex", "state", "remaining", "duplicated", "result", "resultFailure", "regexMatch", "str", "string", "fromGenerator", "iterator", "__spreadProps", "__spreadValues", "fail", "message", "wrapFail", "parser", "wrapper", "e", "ParseError", "debugTrace", "log", "formatState", "end", "runInner", "iter", "step", "run", "input", "runToEnd", "next", "maybe", "parser", "fromGenerator", "startState", "e", "many", "results", "state", "result", "many1", "one", "multiple", "choice", "parsers", "errors", "i", "ParseError", "a", "b", "resultFailure", "error", "sequence", "count", "num", "sepBy1", "sepParser", "valParser", "maybeSeparator", "sepResult", "sepBy", "maybeParser", "first", "peek", "until", "terminator", "maybeEndState", "__spreadProps", "__spreadValues", "between", "start", "end", "data", "map", "fn", "surround", "left", "val", "right", "v", "buildExpressionParser", "operators", "parseTermFactory", "parseTerm", "preOps", "postOps", "binOps", "precedence", "operator", "parseExprTerm", "preFuncs", "postFuncs", "f", "parseExpressionPrecedence", "minPrec", "action", "associativity", "op", "nextMinPrec", "VERSION"]
}
