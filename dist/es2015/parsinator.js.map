{
  "version": 3,
  "sources": ["../../src/lib/ParserTypes.ts", "../../src/lib/ParserHelpers.ts", "../../src/lib/Parser.ts", "../../src/lib/ParserCombinators.ts", "../../src/parsinator.ts"],
  "sourcesContent": ["export interface ParseState {\n  input: string;\n  offset: number;\n}\nexport interface ParseResult<T> {\n  value: T;\n  state: ParseState;\n}\n\nexport interface Parser<T> {\n  (): Generator<number | ParseState, T, ParseState>;\n  [Symbol.iterator](): Generator<number | ParseState, T, ParseState>;\n  parserName: string;\n}\n\nexport class ParseError extends Error {\n  public line: number;\n  public col: number;\n  public offset: number;\n  public input: string;\n  public msg: string;\n  public state: ParseState;\n\n  constructor(msg: string, line: number, col: number, state: ParseState) {\n    super(`Parse failure at ${line}:${col}: ${msg}\\n${formatState(state)}`);\n    this.line = line;\n    this.col = col;\n    this.msg = msg;\n    this.state = state;\n    this.offset = state.offset;\n    this.input = state.input;\n  }\n}\n\nexport function formatState(state: ParseState): string {\n  var startOffset = Math.max(0, state.offset - 40);\n  var endOffset = Math.min(state.input.length, state.offset + 40);\n  var substr =\n    (startOffset === 0 ? \"\" : \"...\") +\n    state.input.replace(/[\\t\\r\\n\\v\\f]/g, \"\u00B7\").slice(startOffset, endOffset) +\n    (endOffset === state.input.length ? \"\" : \"...\");\n  var charsBefore =\n    (startOffset === 0 ? 0 : 3) +\n    state.input.slice(startOffset, state.offset).length;\n  var marker = \" \".repeat(charsBefore) + \"^\";\n  return `-> \u00AB${substr}\u00BB\\n    ${marker} `;\n}\n", "import { ParseError, ParseState, ParseResult } from \"./ParserTypes\";\n\nexport function resultSuccess<T>(\n  value: T,\n  input: string,\n  offset: number\n): ParseResult<T> {\n  return {\n    value: value,\n    state: {\n      input: input,\n      offset: offset,\n    },\n  };\n}\n\nexport function resultFailure<T>(msg: string, state: ParseState): ParseError {\n  var lines = 0;\n  var lastLineStart = 0;\n  for (var i = 0; i < state.offset; ++i) {\n    if (state.input[i] === \"\\n\") {\n      lines++;\n      lastLineStart = i + 1;\n    }\n  }\n  var line = 1 + lines;\n  var col = 1 + state.offset - lastLineStart;\n  return new ParseError(msg, line, col, state);\n}\n", "import {\n  Parser,\n  ParseState,\n  ParseResult,\n  ParseError,\n  formatState,\n} from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\n\nexport function makeParser<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName: string\n): Parser<V> {\n  return Object.assign(() => generator(), {\n    [Symbol.iterator]: generator,\n    parserName,\n  });\n}\n\n/**\n * Produce the full string match from a regular expression.\n *\n * @param regex The regular expression to match\n * @return A parser producing the string matched by the regular expression\n */\nexport function regex(regex: RegExp): Parser<string> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return result[0];\n  }, `regex:${regex.source}`);\n}\n\n/**\n * Produce the full match and all groups from a regular expression.\n *\n * Produces a string array; item 0 is the full match.\n *\n * @param regex The regular expression to match\n * @return A parser producing an array of matching groups; item 0 is the full matching string\n */\nexport function regexMatch(regex: RegExp): Parser<string[]> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    var remaining = state.input.slice(state.offset);\n    var duplicated = new RegExp(regex);\n    var result = duplicated.exec(remaining);\n    if (result === null || result.index !== 0) {\n      throw resultFailure(\n        `regex /${regex.source}/${regex.flags} doesn't match`,\n        state\n      );\n    }\n    yield result[0].length;\n    return Array.from(result);\n  }, `regexMatch:${regex.source}`);\n}\n\n/**\n * Produce a string value.\n *\n * @param string the string value to parse\n * @return A parser producing the matched string\n */\nexport function str<T extends string>(string: T): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    if (state.input.substr(state.offset, string.length) === string) {\n      yield string.length;\n      return string;\n    } else {\n      throw resultFailure(`\"${string}\" not found`, state);\n    }\n  }, `str:${string}`);\n}\n\n/**\n * Produce the return value of the generator, which may yield to sub-parsers.\n *\n * Yielded parsers evaluate to their produced value.\n *\n * @param generator A generator function which yields Parsers and returns value\n * @return A parser producing the returned value\n */\nexport function fromGenerator<V>(\n  generator: () => Generator<number | ParseState, V, ParseState>,\n  parserName?: string\n): Parser<V> {\n  return makeParser(function* () {\n    let state: ParseState = yield 0;\n    var iterator: Iterator<number | ParseState, V, ParseState> = generator();\n    while (true) {\n      var result = iterator.next(state);\n      if (result.done) {\n        yield state;\n        return result.value;\n      } else {\n        if (typeof result.value === \"number\") {\n          state = { ...state, offset: state.offset + result.value };\n        } else {\n          state = result.value;\n        }\n        yield state;\n      }\n    }\n  }, parserName || generator.name);\n}\n\n/**\n * Return a parser which always fails with a specific error message.\n *\n * @param message the message to fail with\n */\nexport function fail<T>(message: string): Parser<T> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    throw resultFailure(message, state);\n  }, `fail:${message}`);\n}\n\n/**\n * Return a parser which when the wrapped parser fails, provides an alternate error message.\n *\n * @param parser a parser whose error message is inadequate\n * @param wrapper a function to add more information to an error message\n */\nexport function wrapFail<T>(\n  parser: Parser<T>,\n  wrapper: (message: string) => string\n) {\n  return makeParser(function* () {\n    try {\n      return yield* parser;\n    } catch (e) {\n      if (e instanceof ParseError) {\n        const message = wrapper(e.msg);\n        throw resultFailure(message, { input: e.input, offset: e.offset });\n      }\n      throw e;\n    }\n  }, \"wrapFail\");\n}\n\n/**\n * Produce nothing and consume nothing, just log the parser state to a log\n *\n * @param log A logging function\n */\nexport function debugTrace(log: (str: string) => void): Parser<undefined> {\n  return makeParser(function* () {\n    const state: ParseState = yield 0;\n    log(formatState(state));\n    return undefined;\n  }, \"debugTrace\");\n}\n\n/**\n * @var end A parser which produces null at the end of input and fails if there is more input.\n */\nexport const end: Parser<null> = makeParser(function* () {\n  const state: ParseState = yield 0;\n  if (state.offset >= state.input.length) {\n    return null;\n  } else {\n    throw resultFailure(\"Not at end of string\", state);\n  }\n}, \"end\");\n\nfunction runInner<T>(parser: Parser<T>, state: ParseState): ParseResult<T> {\n  const iter = parser();\n  let step = iter.next(state);\n  while (!step.done) {\n    if (typeof step.value === \"number\") {\n      state = { ...state, offset: state.offset + step.value };\n    } else {\n      state = step.value;\n    }\n    step = iter.next(state);\n  }\n  return {\n    value: step.value,\n    state: state,\n  };\n}\n\n/**\n * Run a parser on an input, returning the parser's produced value.\n *\n * The parser does not need to consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function run<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  return runInner(parser, state).value;\n}\n\n/**\n * Run a parser on the full input, returning the parser's produced value.\n *\n * Fails if the parser does not consume the entire input.\n *\n * @param parser The parser to run\n * @param input The input string to run\n * @return The value produced by the parser\n */\nexport function runToEnd<T>(parser: Parser<T>, input: string): T {\n  const state = {\n    input: input,\n    offset: 0,\n  };\n  const result = runInner(parser, state);\n  const next = runInner(end, result.state); // throws on error\n  return result.value;\n}\n", "import { Parser, ParseState, ParseResult, ParseError } from \"./ParserTypes\";\nimport { resultFailure, resultSuccess } from \"./ParserHelpers\";\nimport { fromGenerator } from \"./Parser\";\n\n/**\n * Produce the parser's produced value or null on failure.\n *\n * @param parser the parser to attempt\n * @return a parser producing the wrapped parser's result or null on failure\n */\nexport function maybe<P>(parser: Parser<P>): Parser<P | null> {\n  return fromGenerator(function* maybe() {\n    const startState = yield 0;\n    try {\n      return yield* parser;\n    } catch (e) {\n      yield startState;\n      return null;\n    }\n  }, `maybe(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser any number of times (including zero).\n *\n * @param parser a parser to match multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many() {\n    var results: P[] = [];\n    while (true) {\n      const state = yield 0;\n      try {\n        var result = yield* parser;\n      } catch (e) {\n        yield state;\n        return results;\n      }\n      results.push(result);\n    }\n  }, `many(${parser.parserName})`);\n}\n\n/**\n * Produce an array of items from applying a parser at least once.\n *\n * @param parser the parser to execute multiple times\n * @return a parser producing an array of parsed values\n */\nexport function many1<P>(parser: Parser<P>): Parser<P[]> {\n  return fromGenerator(function* many1() {\n    var one = yield* parser;\n    var multiple = yield* many(parser);\n    return [one].concat(multiple);\n  }, `many1(${parser.parserName})`);\n}\n\n/**\n * Produce the first successful result of matching the provided parsers.\n *\n * @param parsers an array of parsers to try\n * @return a parser producing the first succeeding parser's value\n */\nexport function choice<V>(parsers: Parser<V>[]): Parser<V> {\n  return fromGenerator(function* choice() {\n    var errors: ParseError[] = [];\n    const startState = yield 0;\n    for (var i = 0; i < parsers.length; ++i) {\n      try {\n        return yield* parsers[i];\n      } catch (e) {\n        if (e instanceof ParseError) {\n          errors.push(e);\n        } else {\n          throw e;\n        }\n        yield startState;\n      }\n    }\n    const state = yield 0;\n    yield startState;\n    errors.sort((a, b) => b.offset - a.offset);\n    throw resultFailure(\n      \"Multiple choices; potential matches:\\n- \" +\n        errors\n          .map((error) => error.message.split(\"\\n\").join(\"\\n  \"))\n          .join(\"\\n- \"),\n      state\n    );\n  }, `choice(${parsers.map((parser) => parser.parserName).join(\",\")})`);\n}\n\n/**\n * Produce a parser which runs the parsers in sequence, returning an array of results.\n *\n * @param parsers the parsers to execute in sequence\n * @return a parser producing an array of parsed values\n */\nexport function sequence<V>(parsers: Parser<V>[]): Parser<V[]> {\n  return fromGenerator(function* sequence() {\n    var results: V[] = [];\n    for (var i = 0; i < parsers.length; ++i) {\n      const state = yield 0;\n      results.push(yield* parsers[i]);\n    }\n    return results;\n  }, `sequence(${parsers.map((parser) => parser.name).join(\",\")})`);\n}\n\n/**\n * Produce an array of values from a parser run a specific number of times.\n *\n * @param num the number of times to run the parser\n * @param parser the parser to repeat\n * @return a parser producing an array of parsed values\n */\nexport function count<V>(num: number, parser: Parser<V>): Parser<V[]> {\n  return fromGenerator(function* count() {\n    var results: V[] = [];\n    for (var i = 0; i < num; ++i) {\n      results.push(yield* parser);\n    }\n    return results;\n  }, `count(${num},${parser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser must match at least once.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy1<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  return fromGenerator(function* sepBy1() {\n    var results: V[] = [];\n    while (true) {\n      results.push(yield* valParser);\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n    }\n  }, `sepBy1(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce an array of values obtained from a value parser which are each separated by a separator parser.\n *\n * The value parser may not match at all.\n *\n * @param sepParser a parser producing ignored separation values\n * @param valParser a parser producing values desired\n * @return a parser producing valParser values and consuming valParser/sepParser/valParser/...etc input\n */\nexport function sepBy<S, V>(\n  sepParser: Parser<S>,\n  valParser: Parser<V>\n): Parser<V[]> {\n  var maybeSeparator = maybe(sepParser);\n  var maybeParser = maybe(valParser);\n  return fromGenerator(function* sepBy() {\n    var results: V[] = [];\n    var first = yield* maybeParser;\n    if (first === null) {\n      return results;\n    } else {\n      results.push(first);\n    }\n    while (true) {\n      var sepResult = yield* maybeSeparator;\n      if (sepResult === null) {\n        return results;\n      }\n      results.push(yield* valParser);\n    }\n  }, `sepBy(${sepParser.parserName},${valParser.parserName})`);\n}\n\n/**\n * Produce a value by running the parser, but not advancing the parsed state.\n *\n * @param parser a parser producing any value\n * @return a parser producing the wrapped parser's value\n */\nexport function peek<P>(parser: Parser<P>): Parser<P> {\n  return fromGenerator(function* peek() {\n    const startState = yield 0;\n    let result: P;\n    try {\n      result = yield* parser;\n    } catch (e) {\n      yield startState;\n      throw e;\n    }\n    yield startState;\n    return result;\n  }, `peek(${parser.parserName})`);\n}\n\n/**\n * Produce the string input consumed until the terminator parser matches.\n *\n * The terminator parser is not consumed.\n *\n * @param terminator A parser that consumes an end token\n * @return A parser producing the string input consumed until the terminator parser.\n */\nexport function until<T>(terminator: Parser<T>): Parser<string> {\n  return fromGenerator(function* until() {\n    let state = yield 0;\n    for (var i = state.offset; i <= state.input.length; ++i) {\n      // why i <= len? end terminators only match if offset = len.\n      // Try setting state\n      const maybeEndState = yield { ...state, offset: i };\n      try {\n        yield* terminator;\n        yield maybeEndState;\n        return state.input.slice(state.offset, i);\n      } catch (e) {\n        // ignore and proceed\n      }\n    }\n    throw resultFailure(\"Didn't find terminator\", state);\n  }, `until(${terminator.parserName})`);\n}\n\n/**\n * Produce the string input between the start and end parsers.\n *\n * @param start A parser consuming a start token\n * @param end A parser consuming an end token\n */\nexport function between<T>(start: Parser<T>, end: Parser<T>): Parser<string> {\n  return fromGenerator(function* between() {\n    yield* start;\n    var data = yield* until(end);\n    yield* end;\n    return data;\n  }, `between(${start.parserName},${end.parserName})`);\n}\n\n/**\n * Produce a value transformed by a provided function.\n *\n * @param parser the parser to wrap\n * @param fn function to transform the value produced by the parsed\n */\nexport function map<V, W>(parser: Parser<V>, fn: (val: V) => W): Parser<W> {\n  return fromGenerator(function* map() {\n    var result = yield* parser;\n    return fn(result);\n  }, `map(${parser.parserName})`);\n}\n\n/**\n * Produce a value obtained after a prefix parser and before a suffix parser\n *\n * @param left a prefix parser that the produced value is ignored\n * @param val the parser whose produced value is desired\n * @param right a suffix parser that the produced value is ignored\n */\nexport function surround<L, T, R>(\n  left: Parser<L>,\n  val: Parser<T>,\n  right: Parser<R>\n): Parser<T> {\n  return fromGenerator(function* surround() {\n    yield* left;\n    var v: T = yield* val;\n    yield* right;\n    return v;\n  }, `surround(${left.parserName},${val.parserName},${right.parserName})`);\n}\n\nexport type OperatorActionUnary<T> = (val: T) => T;\nexport interface OperatorDeclUnary<T> {\n  parser: Parser<OperatorActionUnary<T>>;\n  fixity: \"prefix\" | \"postfix\";\n}\n\nexport type OperatorActionBinary<T> = (left: T, right: T) => T;\nexport interface OperatorDeclBinary<T> {\n  parser: Parser<OperatorActionBinary<T>>;\n  fixity: \"infix\";\n  associativity: \"left\" | \"right\";\n}\n\nexport type OperatorDecl<T> = OperatorDeclUnary<T> | OperatorDeclBinary<T>;\nexport type OperatorDecls<T> = OperatorDecl<T>[];\n\n/**\n * Build a parser which parses and produces arbitrary binary and unary expressions.\n *\n * buildExpressionParser deals with the heavy lifting of dealing with operator fixity, precedence, and associativity.\n *\n * As an example, here's a very simple arithmetic parser:\n *\n *     var number = Parser.map(Parser.regex(/[0-9]+/), (str) => parseInt(str, 10));\n *\n *     var operator = (opstr, action) => Parser.map(Parser.str(opstr), () => action);\n *\n *     var negate = operator('-', (val) => -val);\n *     var sum = operator('+', (x, y) => x + y);\n *     var multiply = operator('*', (x, y) => x * y);\n *     var exponent = operator('^', (x, y) => Math.pow(x, y));\n *\n *     var evaluate = Parser.buildExpressionParser([\n *         { fixity: \"prefix\", parser: negate },\n *         { fixity: \"infix\", associativity: \"right\", parser: exponent },\n *         { fixity: \"infix\", associativity: \"left\", parser: multiply },\n *         { fixity: \"infix\", associativity: \"left\", parser: sum }\n *     ], () => Parser.choice([\n *         Parser.surround(Parser.str(\"(\"), evaluate, Parser.str(\")\")),\n *         number\n *     ]));\n *\n *     Parser.runToEnd(evaluate, \"1+2*3+1\"); // evaluates to 8\n *     Parser.runToEnd(evaluate, \"(1+2)*-(3+1)\"); // evaluates to -12\n *     Parser.runToEnd(evaluate, \"3^3^3\"); // evaluates to 7625597484987\n *\n * @param operators A an array of `OperatorDecl` objects, in precedence order from highest precedence to lowest precedence\n * @param parseTermFactory A factory method that returns a parser which produces the individual terms of an expression; this itself may reference the returned parser, so it can be used to implement parenthetical sub-expressions\n */\nexport function buildExpressionParser<T>(\n  operators: OperatorDecls<T>,\n  parseTermFactory: () => Parser<T>\n): Parser<T> {\n  var parseTerm: Parser<T> | null = null;\n  var preOps: Parser<OperatorActionUnary<T>>[] = [];\n  var postOps: Parser<OperatorActionUnary<T>>[] = [];\n  var binOps: {\n    precedence: number;\n    associativity: \"left\" | \"right\";\n    parser: Parser<OperatorActionBinary<T>>;\n  }[] = [];\n  for (let i = 0; i < operators.length; ++i) {\n    let precedence: number = operators.length - i;\n    let operator = operators[i];\n    switch (operator.fixity) {\n      case \"infix\":\n        binOps.push({\n          precedence,\n          associativity: operator.associativity,\n          parser: operator.parser,\n        });\n        break;\n      case \"postfix\":\n        postOps.push(operator.parser);\n        break;\n      case \"prefix\":\n        preOps.push(operator.parser);\n        break;\n    }\n  }\n\n  var parseExprTerm = fromGenerator(function* exprParserTerm() {\n    var preFuncs: OperatorActionUnary<T>[] = [];\n    var postFuncs: OperatorActionUnary<T>[] = [];\n    var f: OperatorActionUnary<T> | null = null;\n    do {\n      f = yield* maybe(choice(preOps));\n      if (f !== null) {\n        preFuncs.push(f);\n      }\n    } while (f !== null);\n    if (parseTerm === null) {\n      parseTerm = parseTermFactory();\n    }\n    var result: T = yield* parseTerm;\n    do {\n      f = yield* maybe(choice(postOps));\n      if (f !== null) {\n        postFuncs.push(f);\n      }\n    } while (f !== null);\n    for (let f of preFuncs) {\n      result = f(result);\n    }\n    for (let f of postFuncs) {\n      result = f(result);\n    }\n    return result;\n  }, `expressionParser:term`);\n\n  // This uses the precedence climbing/TDOP algorithm\n  // See http://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing\n  function parseExpressionPrecedence(minPrec: number): Parser<T> {\n    return fromGenerator(function* exprParserPrecedence() {\n      var left: T = yield* parseExprTerm;\n      while (true) {\n        var action: OperatorActionBinary<T> | null = null;\n        var associativity: \"left\" | \"right\" | undefined;\n        var precedence: number | undefined;\n        for (var i = 0; i < binOps.length && action === null; ++i) {\n          var op = binOps[i];\n          if (op.precedence >= minPrec) {\n            action = yield* maybe(op.parser);\n            associativity = op.associativity;\n            precedence = op.precedence;\n          }\n        }\n        if (action === null) {\n          // if action is not null, associativity and precedence are both not undefined\n          return left;\n        }\n        var nextMinPrec: number;\n        if (associativity === \"left\") {\n          nextMinPrec = <number>precedence + 1;\n        } else {\n          nextMinPrec = <number>precedence;\n        }\n        var right = yield* parseExpressionPrecedence(nextMinPrec);\n        left = action(left, right);\n      }\n    }, `expressionParser:precedence`);\n  }\n  return parseExpressionPrecedence(0);\n}\n", "declare const BUILD_VERSION: string | undefined;\n\nexport const VERSION =\n  typeof BUILD_VERSION === \"undefined\" ? \"debug\" : BUILD_VERSION;\n\nexport {\n  str,\n  regex,\n  regexMatch,\n  end,\n  fail,\n  wrapFail,\n  debugTrace,\n  run,\n  runToEnd,\n  fromGenerator,\n} from \"./lib/Parser\";\n\nexport {\n  maybe,\n  many,\n  many1,\n  choice,\n  sequence,\n  count,\n  sepBy,\n  sepBy1,\n  peek,\n  until,\n  between,\n  map,\n  surround,\n  OperatorActionUnary,\n  OperatorActionBinary,\n  OperatorDeclBinary,\n  OperatorDeclUnary,\n  OperatorDecl,\n  OperatorDecls,\n  buildExpressionParser,\n} from \"./lib/ParserCombinators\";\n\nexport { Parser, ParseError, ParseState, ParseResult } from \"./lib/ParserTypes\";\n"],
  "mappings": "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",
  "names": ["regex", "maybe", "many", "many1", "choice", "sequence", "count", "sepBy1", "sepBy", "peek", "until", "end", "between", "map", "surround", "f"]
}
